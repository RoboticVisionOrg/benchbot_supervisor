#!/usr/bin/env python
from __future__ import print_function

from flask import Flask, jsonify, request, abort
import rospy
import cv2
import base64
import json
import yaml
import time
import math
import signal
import types
import importlib 
import sys
import gevent
from gevent.pywsgi import WSGIServer
from gevent.event import Event
from threading import Lock

from cv_bridge import CvBridge, CvBridgeError

class UnknownRouteError(Exception):
    def __init__(self, route):
        Exception.__init__(self)
        self.route = route

    def __str__(self):
        return 'Unknown route: ' + self.route

class UnknownCallbackError(Exception):
    def __init__(self, route, method):
        Exception.__init__(self)
        self.route = route
        self.method = method

    def __str__(self):
        return 'Unknown callback: ' + self.route + ' <' + self.method + '>'

class Supervisor(object):
    def __init__(self, task_file=None):
        rospy.init_node('benchbot_supervisor')
    
        self.subscribers = []
        self.callbacks = {
            'get': {}, 
            'post': {}
        }

        self.spec = {}
        self.data = {}

        self.bridge = CvBridge()
        self.lock = Lock()

        self.progress = []
        
        if task_file:
            self.load(task_file)

    def load(self, filename):
        with open(filename) as f:
            self.spec = json.loads(f.read())

        for route_id in self.spec['routes']:
            if 'get' in self.spec['routes'][route_id]:
                
                if 'topic' in self.spec['routes'][route_id]['get']:
                    if not 'topic_type' in self.spec['routes'][route_id]['get']:
                        raise Exception('Missing topic type for route: ' + route_id)
                    
                    self.register_subscriber(route_id, self.spec['routes'][route_id]['get']['topic'], self.spec['routes'][route_id]['get']['topic_type'])

                elif 'callback' in self.spec['routes'][route_id]['get']:
                    self.register_callback(route_id, self.spec['routes'][route_id]['get']['callback'], 'get')

                else:
                    raise Exception('Required topic or callback missing for get method of route: ' + route_id)

            if 'post' in self.spec['routes'][route_id]:
                if 'callback' in self.spec['routes'][route_id]['post']:
                    self.register_callback(route_id, self.spec['routes'][route_id]['post']['callback'], 'post')

                else:
                    raise Exception('Required topic or callback missing for post method of route: ' + route_id)

        for objective_id in self.spec['objectives']:
            pass

    def register_subscriber(self, route_id, topic_name, topic_type_name):
        module, typename = topic_type_name.split('/')
        topic_type = getattr(importlib.import_module(module + '.msg'), typename)
        self.subscribers.append(rospy.Subscriber(topic_name, topic_type, self.__updater(route_id)))

    def register_callback(self, route, callback_type_name, method='post'):
        module, typename = callback_type_name.split('/')
        func = getattr(importlib.import_module(module), typename)
        self.callbacks[method][route] = func

    def handle_initialise(self):
        self.progress = []

    def handle_complete(self, data):
        self.progress.append(data)

    def handle_get(self, route):
        if not route in self.spec['routes'] or not 'get' in self.spec['routes'][route]:
            raise UnknownRouteError(route)
        
        if route in self.callbacks['get']:
            return self.callbacks['get'][route]()

        if not 'fields' in self.spec['routes'][route]['get']:
            with self.lock:
                return self.__toJSON(self.data[route]) if route in self.data else {}
        
        retval = {}
        for key in self.spec['routes'][route]['get']['fields']:
            field_type = self.spec['routes'][route]['get']['fields'][key]['type'] if 'type' in self.spec['routes'][route]['get']['fields'][key] else None
            field_name = self.spec['routes'][route]['get']['fields'][key]['name'] if 'name' in self.spec['routes'][route]['get']['fields'][key] else key

            if field_type == 'image':
                
                with self.lock:
                    img = self.bridge.imgmsg_to_cv2(self.data[route], "bgr8")
        
                _, buf = cv2.imencode('.png', img)
                retval[field_name] = base64.b64encode(buf)
            else:
                steps = key.split('.')
                
                with self.lock:
                    retval[field_name] = getattr(self.data[route], steps.pop(0))
                
                for step in steps:
                    retval[field_name] = getattr(retval[field_name], step)

                if hasattr(retval[field_name], '__slots__'):
                    retval[field_name] = Supervisor.__toJSON(retval[field_name])
        
        return retval

    def handle_post(self, route, data):
        if not route in self.spec['routes'] or not 'post' in self.spec['routes'][route]:
            raise UnknownRouteError(route)

        if not route in self.callbacks['post']:
            raise UnknownCallbackError(route, 'post')

        return self.callbacks['post'][route](**data)

    def run(self, address='0.0.0.0', port=8081):
        app = Flask(__name__)
        @app.route('/')
        # pylint: disable=unused-variable
        def main():
            return jsonify({
                'get': [self.spec['routes'][route]['name'] if 'name' in self.spec['routes'][route] else route for route in self.spec['routes'] if 'get' in self.spec['routes'][route]], 
                'send': [self.spec['routes'][route]['name'] if 'name' in self.spec['routes'][route] else route for route in self.spec['routes'] if 'post' in self.spec['routes'][route]]
            })

        @app.route('/objectives')
        # pylint: disable=unused-variable
        def objectives():
            return jsonify(self.spec['objectives'])

        @app.route('/init', methods=['POST'])
        # pylint: disable=unused-variable
        def initialise():
            self.handle_initialise()

        @app.route('/complete', methods=['POST'])
        # pylint: disable=unused-variable
        def complete():
            try:
                return jsonify(self.handle_complete(request.get_json(silent=True)))
            except Exception as e:
                print(str(e))
                abort(500)

        @app.route('/<route>', methods=['GET'])
        # pylint: disable=unused-variable
        def get(route):
            try:
                return jsonify(self.handle_get(route))
            except UnknownRouteError:
                abort(404)
            except UnknownCallbackError:
                abort(500)

        @app.route('/<route>', methods=['POST'])
        # pylint: disable=unused-variable
        def post(route):
            try:
                return jsonify(self.handle_post(route, request.get_json(silent=True)))
            except UnknownRouteError:
                abort(404)
            except UnknownCallbackError:
                abort(500)
            except Exception as e:
                print(str(e))

        http_server = WSGIServer((address, port), app)
        http_server.start()

        evt = Event()

        gevent.signal(signal.SIGQUIT, evt.set)
        gevent.signal(signal.SIGTERM, evt.set)
        gevent.signal(signal.SIGINT, evt.set)

        print('Server started on', address + ':' + str(port))
        evt.wait()
        print("Shutting down server")

        http_server.stop()

    def __updater(self, route_id):
        def _updater(data):
            with self.lock:
                self.data[route_id] = data
        return _updater

    @staticmethod
    def __toJSON(data):
        retval = {}
        for key in data.__slots__:
            if hasattr(getattr(data, key), '__slots__'):
                retval[key] = Supervisor.__toJSON(getattr(data, key))
            else:
                retval[key] = getattr(data, key)
        return retval

if __name__ == '__main__':
    if len(sys.argv) < 2:
        print('Error - missing task specification file. Usage: benchbot_supervisor TASK_FILE')
        sys.exit(1)

    supervisor = Supervisor(sys.argv[1])
    supervisor.run()